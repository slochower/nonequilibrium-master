from motors.simulation import Simulation
import numpy as np

def summarize_fluxes(name, concentration, data_source='adk_md_data', catalytic_rate=None,
                     directory=None):
    """
    Calculate the probability fluxes using default parameters (except substrate concentration and
    catalytic rate) for a given protein system. Driven flux is reciprocating flux. Intersurface flux is hitherto not analyzed.
    """
    this = Simulation(data_source=data_source)
    this.cSubstrate = concentration
    if catalytic_rate:
        this.catalytic_rate = catalytic_rate
    this.name = name
    this.simulate(directory=directory)
    directional_flux = np.mean(this.flux_u + this.flux_b)
    intersurface_flux = max(abs(this.flux_ub))
    # Make all flux on each surface positive
    unbound_flux = abs(this.flux_u)
    bound_flux = abs(this.flux_b)
    # Now find the maximum on either surface
    max_unbound = max(unbound_flux)
    max_bound = max(bound_flux)
    driven_flux = max([max_unbound, max_bound])
    return directional_flux, intersurface_flux, driven_flux

def summarize_power_and_load(name, concentration, data_source='adk_md_data', negative=False,
                             catalytic_rate=None, directory=None):
    """
    Calculate the maximum power and the applied load at the maximum power using default paramters (except substrate concentration and catalytic rate) for a given protein system.
    """
    this = Simulation(data_source=data_source)
    this.cSubstrate = concentration
    if catalytic_rate:
        this.catalytic_rate = catalytic_rate
    this.name = name
    this.load = True
    # Initialize the applied load to be something small, and we'll increase
    # from there.
    slope = 0.000
    increment = 0.00001
    loads = []
    power_given_load = []
    flux_given_load = []
    # I'm sure there is a better way to do this, but this works. If I omit this step, then "left"
    # net probability flux (i.e., negative flux) gives negative power output.
    while True:
        if negative:
            this.load_slope = -slope
        else:
            this.load_slope = slope
        this.simulate(directory=directory)
        
        flux = np.mean(this.flux_u + this.flux_b)
        power = this.load_slope * np.mean(this.flux_u + this.flux_b)
        loads.append(this.load_slope)
        flux_given_load.append(flux)
        power_given_load.append(power)
        max_power = max(power_given_load)


        # Power output as a function of load is an upside-down 'u' shape. Check the power trend to
        # see if we should break out of the loop.
        max_power_index = power_given_load.index(max_power)
        # Is the maximum power the last element?
        if max_power > power_given_load[0] and max_power > power_given_load[-1]:
            # But let's check and make sure the power doesn't continue to increase,
            # before we break
            slope += increment
            if negative:
                this.load_slope = -slope
            else:
                this.load_slope = slope
            this.simulate(directory=directory)
            power = this.load_slope * np.mean(this.flux_u + this.flux_b)
            if max_power > power:
                # break
                return max_power, loads[max_power_index]
        if max_power == 0 and len(power_given_load) > 100:
            # This can happen if the maximum load that can be supported is even smaller than the
            # increment size. For simplicity, we don't report the power generated by this angle. It
            # would not be difficult to do a more thorough investigation of these angles.
            return 0.0, 0.0
        
        if len(power_given_load) % 100 == 0:
            increment *= 10
        if len(power_given_load) > 1000:
            print('Unable to zero in on the maximum power after 1000 iterations.')
        if slope > 10:
            print('The load function is too steep.')
            break
        slope += increment

def return_concentration_slice(df, concentration):
    """
    This helper function slices a dataframe at a particular substrate concentration.
    """
    tmp = df[np.round(df['Concentration'], 1) == np.round(concentration, 1)]
    return tmp


def return_fluxes_and_velocity(protein, name, concentrations, catalytic_rate=None,
                               directory=None):
    """
    This helper function will return the turnover rate and the fluxes over a concentration range.
    """
    directional_flux, reciprocating_flux, velocity = [], [], []
    for concentration in concentrations:
        this = Simulation(data_source=protein)
        this.name = name
        this.cSubstrate = concentration
        if catalytic_rate:
            this.catalytic_rate = catalytic_rate
        this.simulate(directory=directory)
        directional_flux.append(np.mean(this.flux_u + this.flux_b))
        reciprocating_flux.append(
            np.max(np.hstack((abs(this.flux_u), abs(this.flux_b)))))
        velocity.append(
            np.sum(this.ss[this.bins:2 * this.bins]) * this.catalytic_rate)
    return directional_flux, reciprocating_flux, velocity
